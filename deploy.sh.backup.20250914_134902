#!/bin/bash

# Buddian Deployment Script for Ubuntu 24.04
# This script fixes Docker build issues and deploys Buddian successfully

set -e  # Exit on any error

# Script validation and environment detection
validate_script_environment() {
    # Check if running with proper shell
    if [ -z "$BASH_VERSION" ]; then
        echo "ERROR: This script requires bash. Please run with: bash $0"
        exit 1
    fi
    
    # Check script permissions
    if [ ! -x "$0" ]; then
        echo "WARNING: Script does not have execute permissions"
        echo "Run: chmod +x $0"
    fi
    
    # Debug output if enabled
    if [ "$DEPLOY_DEBUG" = "1" ]; then
        echo "DEBUG: Script validation passed"
        echo "DEBUG: Bash version: $BASH_VERSION"
        echo "DEBUG: Shell: $SHELL"
        echo "DEBUG: Script path: $0"
        echo "DEBUG: Working directory: $(pwd)"
        echo "DEBUG: User: $(whoami)"
        echo "DEBUG: Environment: $(uname -a)"
    fi
}

# Function to check required files exist
check_required_files() {
    local required_files=(
        "docker-compose.yml"
        "packages/bot/package.json"
        "packages/bot/Dockerfile"
        "convex.json"
    )
    
    for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
            echo "ERROR: Required file not found: $file"
            echo "Please ensure you're running this script from the project root directory"
            exit 1
        fi
    done
    
    if [ "$DEPLOY_DEBUG" = "1" ]; then
        echo "DEBUG: All required files found"
    fi
}

# Enhanced error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "ERROR: Script failed at line $line_number with exit code $exit_code"
    echo "Command that failed: $BASH_COMMAND"
    echo ""
    echo "Troubleshooting steps:"
    echo "1. Check file permissions: ls -la deploy.sh"
    echo "2. Verify line endings: file deploy.sh"
    echo "3. Run with debugging: DEPLOY_DEBUG=1 bash deploy.sh"
    echo "4. Check system compatibility: uname -a"
    echo "5. Verify bash installation: which bash"
    echo ""
    exit $exit_code
}

# Set up error trap
trap 'handle_error $LINENO' ERR

# Run initial validations
validate_script_environment
check_required_files

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Docker Compose command detection
COMPOSE_CMD="docker compose"
if command -v docker-compose >/dev/null 2>&1; then 
    COMPOSE_CMD="docker-compose"
fi

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Helper function to extract environment variables with proper comment stripping
get_env() {
    # Usage: get_env VAR_NAME
    local raw
    raw=$(grep -E "^$1=" .env | tail -n 1 | cut -d'=' -f2-)
    echo "$raw" | sed -E 's/[[:space:]]*#.*$//' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g' | tr -d '"\''
}

# Function to check Docker installation
check_docker() {
    log_info "Checking Docker installation..."
    
    if ! command_exists docker; then
        log_error "Docker is not installed. Please install Docker first:"
        echo "  sudo apt update"
        echo "  sudo apt install -y docker.io"
        echo "  sudo systemctl start docker"
        echo "  sudo systemctl enable docker"
        echo "  sudo usermod -aG docker \$USER"
        echo "  # Log out and back in for group changes to take effect"
        exit 1
    fi
    
    if ! command_exists docker-compose && ! docker compose version >/dev/null 2>&1; then
        log_error "Docker Compose is not installed. Please install Docker Compose:"
        echo "  sudo apt install -y docker-compose-plugin"
        exit 1
    fi
    
    # Check if Docker daemon is running
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker daemon is not running. Please start Docker:"
        echo "  sudo systemctl start docker"
        exit 1
    fi
    
    log_success "Docker is installed and running"
}

# Function to check convex dependency
check_convex_dependency() {
    log_info "Checking Convex dependency..."
    
    BOT_PACKAGE_JSON="packages/bot/package.json"
    
    if [ ! -f "$BOT_PACKAGE_JSON" ]; then
        log_error "Bot package.json not found: $BOT_PACKAGE_JSON"
        exit 1
    fi
    
    if grep -q '"convex"' "$BOT_PACKAGE_JSON"; then
        log_success "Convex dependency found in package.json"
    else
        log_error "Convex dependency missing from $BOT_PACKAGE_JSON"
        log_info "Please add the convex dependency:"
        echo '  "convex": "^1.8.0"'
        exit 1
    fi
}

# Function to check environment file
check_env_file() {
    log_info "Checking environment configuration..."
    
    if [ ! -f ".env" ]; then
        log_warning ".env file not found"
        
        if [ -f ".env.example" ]; then
            log_info "Creating .env from .env.example..."
            cp .env.example .env
            log_warning "Please edit .env file with your actual configuration values:"
            echo "  - CONVEX_URL: Your Convex deployment URL (e.g., https://your-deployment.convex.cloud)"
            echo "  - CONVEX_DEPLOYMENT: Your deployment name (generated by 'npx convex dev')"
            echo "  - CONVEX_ADMIN_KEY: Your Convex admin key"
            echo "  - TELEGRAM_BOT_TOKEN: Your Telegram bot token"
            echo "  - AZURE_OPENAI_ENDPOINT: Your Azure OpenAI endpoint"
            echo "  - AZURE_OPENAI_KEY: Your Azure OpenAI key"
            echo ""
            echo ""
            echo "Configuration guidance:"
            echo "  For development: Run 'npx convex dev' first, then 'cp .env.local .env'"
            echo "  For production server: Manually set production CONVEX_URL, CONVEX_DEPLOYMENT=prod:<name>,"
            echo "                        and CONVEX_ADMIN_KEY from the Convex dashboard. Do not use .env.local."
            echo ""
            echo "After editing .env, run this script again."
            exit 1
        else
            log_error ".env.example file not found. Please create .env file manually with required environment variables."
            exit 1
        fi
    fi
    
    # Check for required Convex environment variables
    if [ -f ".env" ]; then
        log_info "Verifying Convex environment variables..."
        
        if ! grep -q "CONVEX_URL=" ".env" || ! grep -q "CONVEX_DEPLOYMENT=" ".env" || ! grep -q "CONVEX_ADMIN_KEY=" ".env"; then
            log_error "Missing required Convex environment variables in .env file"
            log_info "Required variables:"
            echo "  - CONVEX_URL=https://your-deployment.convex.cloud"
            echo "  - CONVEX_DEPLOYMENT=your-deployment-name"
            echo "  - CONVEX_ADMIN_KEY=your-convex-admin-key"
            echo ""
            if [ -f ".env.local" ]; then
                log_info "For local development, you can copy: cp .env.local .env"
                log_info "For production servers, set \`CONVEX_URL\`, \`CONVEX_DEPLOYMENT=prod:<name>\`, and \`CONVEX_ADMIN_KEY\` from the Convex dashboard; do not use \`.env.local\`."
            else
                log_info "Run 'npx convex dev' to configure your Convex project first"
            fi
            exit 1
        fi
        
        log_success "Convex environment variables found"
    fi
    
    log_success "Environment file exists and configured"
}

# Function to validate Convex credentials for production deployment
validate_convex_credentials() {
    log_info "Validating Convex credentials for production deployment..."
    
    if [ ! -f ".env" ]; then
        log_error ".env file not found"
        return 1
    fi
    
    # Extract Convex configuration values using sanitized helper
    CONVEX_DEPLOYMENT=$(get_env CONVEX_DEPLOYMENT)
    CONVEX_ADMIN_KEY=$(get_env CONVEX_ADMIN_KEY)
    CONVEX_URL=$(get_env CONVEX_URL)
    
    # Check if values are placeholder values
    if [[ "$CONVEX_DEPLOYMENT" == "your-deployment-name" ]] || [[ "$CONVEX_DEPLOYMENT" == "your_deployment_name" ]]; then
        log_error "CONVEX_DEPLOYMENT is still set to placeholder value"
        log_info "Please update CONVEX_DEPLOYMENT in .env file with your actual deployment name"
        return 1
    fi
    
    if [[ "$CONVEX_ADMIN_KEY" == "your_convex_admin_key_here" ]] || [[ "$CONVEX_ADMIN_KEY" == "your-convex-admin-key" ]]; then
        log_error "CONVEX_ADMIN_KEY is still set to placeholder value"
        log_info "Please update CONVEX_ADMIN_KEY in .env file with your actual admin key"
        return 1
    fi
    
    # Detect environment type based on CONVEX_DEPLOYMENT format
    if [[ "$CONVEX_DEPLOYMENT" == dev:* ]]; then
        log_warning "‚ö†Ô∏è  DEVELOPMENT credentials detected (dev:*)"
        log_warning "For Ubuntu server deployment, you should use PRODUCTION credentials"
        echo ""
        log_info "Development vs Production credentials:"
        echo "  ‚Ä¢ Development (dev:deployment-name): For local testing with 'npx convex dev'"
        echo "  ‚Ä¢ Production (prod:deployment-name): For server deployment with full admin key"
        echo ""
        log_info "To use production credentials:"
        echo "  1. Go to https://dashboard.convex.dev"
        echo "  2. Select your production deployment"
        echo "  3. Update your .env file with:"
        echo "     CONVEX_DEPLOYMENT=prod:your-deployment-name"
        echo "     CONVEX_ADMIN_KEY=prod:<deployment>|<token>"
        echo ""
        
        # Unified policy for development credentials
        log_error "Development credentials are not allowed for server deployment"
        log_info "Please use production credentials for server deployment"
        log_info "To override this check, set ALLOW_DEV_DEPLOY=1 environment variable"
        
        if [[ "$ALLOW_DEV_DEPLOY" == "1" ]]; then
            log_warning "‚ö†Ô∏è  OVERRIDE: Proceeding with development credentials (STRONGLY NOT RECOMMENDED)"
            log_warning "This should only be used for testing purposes"
        else
            return 1
        fi
        
    elif [[ "$CONVEX_DEPLOYMENT" == prod:* ]]; then
        log_success "‚úÖ PRODUCTION credentials detected (prod:*)"
        
        # Validate admin key format for production and suggest deployment name
        if [[ "$CONVEX_ADMIN_KEY" == prod:*"|"* ]]; then
            local rest=${CONVEX_ADMIN_KEY#prod:}
            local key_deployment=${rest%%|*}
            if [[ "$CONVEX_DEPLOYMENT" != "prod:$key_deployment" ]]; then
                log_warning "CONVEX_DEPLOYMENT (\"$CONVEX_DEPLOYMENT\") does not match admin key deployment (\"prod:$key_deployment\")."
                log_info "Suggested: CONVEX_DEPLOYMENT=prod:$key_deployment"
            fi
            
            # Also verify CONVEX_URL contains the deployment name
            if [[ "$CONVEX_URL" != *"$key_deployment.convex.cloud"* ]]; then
                log_warning "CONVEX_URL does not match admin key deployment"
                log_info "Expected URL format: https://$key_deployment.convex.cloud"
                log_info "Current URL: $CONVEX_URL"
            fi
        else
            log_warning "Admin key doesn't start with 'prod:' prefix or contain '|' separator"
            log_info "Production admin keys should start with 'prod:' and contain a '|' separator"
            log_info "Please verify your admin key is correct for production deployment"
        fi
        
        # Extract deployment name from CONVEX_DEPLOYMENT
        DEPLOYMENT_NAME=${CONVEX_DEPLOYMENT#prod:}
        
        # Check if URL matches deployment name
        if [[ "$CONVEX_URL" == *"$DEPLOYMENT_NAME.convex.cloud"* ]]; then
            log_success "Convex URL matches deployment name"
        else
            log_warning "Convex URL might not match deployment name"
            log_info "Expected URL format: https://$DEPLOYMENT_NAME.convex.cloud"
            log_info "Current URL: $CONVEX_URL"
        fi
        
    else
        log_error "Invalid CONVEX_DEPLOYMENT format: $CONVEX_DEPLOYMENT"
        log_info "Expected format:"
        echo "  ‚Ä¢ Development: dev:deployment-name"
        echo "  ‚Ä¢ Production: prod:deployment-name"
        echo ""
        log_info "If you have an admin key starting with 'prod:' and containing a '|', use:"
        echo "  CONVEX_DEPLOYMENT=prod:your-deployment-name"
        return 1
    fi
    
    # Check admin key presence for production deployment
    if [[ "$CONVEX_DEPLOYMENT" == prod:* ]] && [[ -z "$CONVEX_ADMIN_KEY" ]]; then
        log_error "CONVEX_ADMIN_KEY is required for production deployment"
        log_info "Get your admin key from https://dashboard.convex.dev"
        return 1
    fi
    
    log_success "Convex credentials validation completed"
    return 0
}

# Function to verify Convex setup
verify_convex_setup() {
    log_info "Verifying Convex setup for Docker build..."
    
    # Check for convex.json presence first
    if [[ ! -f "convex.json" ]]; then
        log_error "convex.json not found at repo root. Ensure Convex project is initialized."
        log_info "Run 'npx convex dev' to initialize your Convex project"
        exit 1
    fi
    
    # Check if convex/_generated/api.ts exists or can be generated
    CONVEX_API_FILE="convex/_generated/api.ts"
    
    if [ -f "$CONVEX_API_FILE" ]; then
        log_success "Convex API file exists: $CONVEX_API_FILE"
    else
        log_warning "Convex API file not found: $CONVEX_API_FILE"
        log_info "Creating typed FunctionReference stub..."
        
        mkdir -p convex/_generated
        cat > "$CONVEX_API_FILE" << 'EOF'
/**
 * Generated Convex API
 * This file contains the generated API exports for Convex functions
 */

import { FunctionReference } from "convex/server";

// Health module functions
export const health = {
  checkConnection: "health:checkConnection" as any as FunctionReference<"query">,
  ping: "health:ping" as any as FunctionReference<"query">,
  getStats: "health:getStats" as any as FunctionReference<"query">,
  recordHealthMetrics: "health:recordHealthMetrics" as any as FunctionReference<"mutation">,
  getSystemHealth: "health:getSystemHealth" as any as FunctionReference<"query">,
  getComponentHealth: "health:getComponentHealth" as any as FunctionReference<"query">,
  getOverallStatus: "health:getOverallStatus" as any as FunctionReference<"query">,
  cleanupHealthRecords: "health:cleanupHealthRecords" as any as FunctionReference<"mutation">,
  getHealthMetricsSummary: "health:getHealthMetricsSummary" as any as FunctionReference<"query">,
};

// Messages module functions  
export const messages = {
  storeMessage: "messages:storeMessage" as any as FunctionReference<"mutation">,
  getMessage: "messages:getMessage" as any as FunctionReference<"query">,
  getMessages: "messages:getMessages" as any as FunctionReference<"query">,
  searchMessages: "messages:searchMessages" as any as FunctionReference<"query">,
  getThreadContext: "messages:getThreadContext" as any as FunctionReference<"query">,
  updateMessageDecisions: "messages:updateMessageDecisions" as any as FunctionReference<"mutation">,
  updateMessageActionItems: "messages:updateMessageActionItems" as any as FunctionReference<"mutation">,
  getMessagesByUser: "messages:getMessagesByUser" as any as FunctionReference<"query">,
  getMessagesByThread: "messages:getMessagesByThread" as any as FunctionReference<"query">,
  getMessagesWithDecisions: "messages:getMessagesWithDecisions" as any as FunctionReference<"query">,
  getMessagesWithActionItems: "messages:getMessagesWithActionItems" as any as FunctionReference<"query">,
  getMessageStats: "messages:getMessageStats" as any as FunctionReference<"query">,
  deleteOldMessages: "messages:deleteOldMessages" as any as FunctionReference<"mutation">,
};

// Users module functions
export const users = {
  getUser: "users:getUser" as any as FunctionReference<"query">,
  getUserById: "users:getUserById" as any as FunctionReference<"query">,
  createUser: "users:createUser" as any as FunctionReference<"mutation">,
  updateUserPreferences: "users:updateUserPreferences" as any as FunctionReference<"mutation">,
  updateLastActive: "users:updateLastActive" as any as FunctionReference<"mutation">,
  getUserLanguage: "users:getUserLanguage" as any as FunctionReference<"query">,
  getActiveUsers: "users:getActiveUsers" as any as FunctionReference<"query">,
  getUserStats: "users:getUserStats" as any as FunctionReference<"query">,
};

// Resources module functions
export const resources = {
  storeResource: "resources:storeResource" as any as FunctionReference<"mutation">,
  getResources: "resources:getResources" as any as FunctionReference<"query">,
  getResourcesByUser: "resources:getResourcesByUser" as any as FunctionReference<"query">,
  searchResources: "resources:searchResources" as any as FunctionReference<"query">,
  getResource: "resources:getResource" as any as FunctionReference<"query">,
  updateResourceSummary: "resources:updateResourceSummary" as any as FunctionReference<"mutation">,
  deleteResource: "resources:deleteResource" as any as FunctionReference<"mutation">,
  getRecentResources: "resources:getRecentResources" as any as FunctionReference<"query">,
  getResourceStats: "resources:getResourceStats" as any as FunctionReference<"query">,
};

// Threads module functions
export const threads = {
  createThread: "threads:createThread" as any as FunctionReference<"mutation">,
  getThreadsByChat: "threads:getThreadsByChat" as any as FunctionReference<"query">,
  getThread: "threads:getThread" as any as FunctionReference<"query">,
  updateThreadActivity: "threads:updateThreadActivity" as any as FunctionReference<"mutation">,
  updateThreadSummary: "threads:updateThreadSummary" as any as FunctionReference<"mutation">,
  addThreadTags: "threads:addThreadTags" as any as FunctionReference<"mutation">,
  removeThreadTags: "threads:removeThreadTags" as any as FunctionReference<"mutation">,
  searchThreads: "threads:searchThreads" as any as FunctionReference<"query">,
  getActiveThreads: "threads:getActiveThreads" as any as FunctionReference<"query">,
  getThreadsByTags: "threads:getThreadsByTags" as any as FunctionReference<"query">,
  getThreadStats: "threads:getThreadStats" as any as FunctionReference<"query">,
  deleteThread: "threads:deleteThread" as any as FunctionReference<"mutation">,
  getThreadMessages: "threads:getThreadMessages" as any as FunctionReference<"query">,
  assignMessageToThread: "threads:assignMessageToThread" as any as FunctionReference<"mutation">,
};

// Search module functions
export const search = {
  searchByKeywords: "search:searchByKeywords" as any as FunctionReference<"query">,
  searchByContext: "search:searchByContext" as any as FunctionReference<"query">,
  getRelatedContent: "search:getRelatedContent" as any as FunctionReference<"query">,
  indexContent: "search:indexContent" as any as FunctionReference<"mutation">,
  searchAll: "search:searchAll" as any as FunctionReference<"query">,
  getSearchSuggestions: "search:getSearchSuggestions" as any as FunctionReference<"query">,
  getPopularSearchTerms: "search:getPopularSearchTerms" as any as FunctionReference<"query">,
};

// Main API export
export const api = {
  health,
  messages,
  users,
  resources,
  threads,
  search,
};

export default api;
EOF
        
        log_success "Typed FunctionReference stub created: $CONVEX_API_FILE"
    fi
    
    # Verify convex service import path uses path alias
    CONVEX_SERVICE_FILE="packages/bot/src/services/convex.ts"
    
    if [ -f "$CONVEX_SERVICE_FILE" ]; then
        if grep -q "import { api } from 'convex/_generated/api';" "$CONVEX_SERVICE_FILE"; then
            log_success "Import path uses path alias in $CONVEX_SERVICE_FILE"
        else
            log_warning "Import statement should use 'convex/_generated/api' path alias in $CONVEX_SERVICE_FILE"
        fi
    else
        log_error "Convex service file not found: $CONVEX_SERVICE_FILE"
        exit 1
    fi
    
    log_success "Convex setup verified"
}

# Function to clean up previous builds
cleanup_docker() {
    log_info "Cleaning up previous Docker builds..."
    
    # Stop and remove existing containers
    if $COMPOSE_CMD ps -q >/dev/null 2>&1; then
        $COMPOSE_CMD down --remove-orphans || true
    fi
    
    # Remove dangling images
    docker image prune -f >/dev/null 2>&1 || true
    
    log_success "Docker cleanup completed"
}

# Function to build and deploy
deploy_services() {
    log_info "Building and deploying Buddian services..."
    
    # Optional Convex deployment
    if [[ "$RUN_CONVEX_DEPLOY" == "1" ]]; then
        log_info "Deploying Convex schema to production..."
        if command_exists npx; then
            npx convex deploy --prod --yes || { log_error "Convex deploy failed"; exit 1; }
            log_success "Convex schema deployed successfully"
        else
            log_error "npx not found. Please install Node.js and npm or deploy schema manually"
            log_info "Run 'npx convex deploy --prod' on your development machine before deployment"
            exit 1
        fi
    fi
    
    # Build with no cache to ensure fresh build
    log_info "Building Docker images..."
    if $COMPOSE_CMD build --no-cache; then
        log_success "Docker images built successfully"
    else
        log_error "Docker build failed"
        log_info "Troubleshooting tips:"
        echo "  1. Check if all required files exist"
        echo "  2. Verify .env file has correct values"
        echo "  3. Ensure convex/_generated/api.ts exists"
        echo "  4. Check Docker logs: $COMPOSE_CMD logs"
        exit 1
    fi
    
    # Start services
    log_info "Starting services..."
    if $COMPOSE_CMD up -d; then
        log_success "Services started successfully"
        
        # Note about nginx profile
        log_info "Note: Nginx service is disabled by default \(requires 'internal-proxy' profile\)"
        log_info "To enable nginx: $COMPOSE_CMD --profile internal-proxy up -d"
    else
        log_error "Failed to start services"
        log_info "Check logs with: $COMPOSE_CMD logs"
        exit 1
    fi
}

# Function to verify deployment
verify_deployment() {
    log_info "Verifying deployment..."
    
    # Wait a moment for services to start
    sleep 5
    
    # Check if containers are running
    if $COMPOSE_CMD ps | grep -q "Up"; then
        log_success "Containers are running"
        
        # Show running services
        echo ""
        log_info "Running services:"
        $COMPOSE_CMD ps
        
    else
        log_error "Some containers are not running properly"
        log_info "Check logs with: $COMPOSE_CMD logs"
        return 1
    fi
    
    # Check container health
    log_info "Checking container health..."
    
    # Get container names
    BOT_CONTAINER=$($COMPOSE_CMD ps -q bot 2>/dev/null || echo "")
    NGINX_CONTAINER=$($COMPOSE_CMD ps -q nginx 2>/dev/null || echo "")
    
    if [ -n "$BOT_CONTAINER" ]; then
        if docker inspect "$BOT_CONTAINER" --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy\|starting"; then
            log_success "Bot service is healthy"
        else
            log_warning "Bot service health check failed or not configured"
        fi
    fi
    
    if [ -n "$NGINX_CONTAINER" ]; then
        if docker inspect "$NGINX_CONTAINER" --format='{{.State.Status}}' 2>/dev/null | grep -q "running"; then
            log_success "Nginx service is running"
        else
            log_warning "Nginx service is not running properly"
        fi
    fi
    
    log_success "Deployment verification completed"
}

# Function to show next steps
show_next_steps() {
    echo ""
    log_success "üéâ Buddian deployment completed successfully!"
    echo ""
    log_info "Next steps:"
    echo "  1. Configure your external nginx/reverse proxy to point to this server"
    echo "  2. Set up SSL certificates \(Let's Encrypt recommended\)"
    echo "  3. Configure your Telegram bot webhook to point to your domain"
    echo ""
    log_info "Useful commands:"
    echo "  ‚Ä¢ View logs: $COMPOSE_CMD logs -f"
    echo "  ‚Ä¢ Restart services: $COMPOSE_CMD restart"
    echo "  ‚Ä¢ Stop services: $COMPOSE_CMD down"
    echo "  ‚Ä¢ Enable nginx proxy: $COMPOSE_CMD --profile internal-proxy up -d"
    echo "  ‚Ä¢ Update deployment: git pull && ./deploy.sh"
    echo ""
    log_info "Troubleshooting:"
    echo "  ‚Ä¢ Check service status: $COMPOSE_CMD ps"
    echo "  ‚Ä¢ View specific service logs: $COMPOSE_CMD logs <service-name>"
    echo "  ‚Ä¢ Rebuild if needed: $COMPOSE_CMD build --no-cache"
    echo ""
    
    # Show external nginx configuration example
    echo ""
    log_info "Example external nginx configuration:"
    echo "server {"
    echo "    listen 80;"
    echo "    server_name your-domain.com;"
    echo "    return 301 https://\$server_name\$request_uri;"
    echo "}"
    echo ""
    echo "server {"
    echo "    listen 443 ssl http2;"
    echo "    server_name your-domain.com;"
    echo ""
    echo "    ssl_certificate /path/to/your/certificate.crt;"
    echo "    ssl_certificate_key /path/to/your/private.key;"
    echo ""
    echo "    location / {"
    echo "        proxy_pass http://localhost:8080;"
    echo "        proxy_set_header Host \$host;"
    echo "        proxy_set_header X-Real-IP \$remote_addr;"
    echo "        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;"
    echo "        proxy_set_header X-Forwarded-Proto \$scheme;"
    echo "    }"
    echo "}"
}

# Main deployment function
main() {
    echo ""
    log_info "üöÄ Starting Buddian deployment on Ubuntu 24.04"
    echo ""
    
    # Check if we're in the right directory
    if [ ! -f "docker-compose.yml" ]; then
        log_error "docker-compose.yml not found. Please run this script from the Buddian project root directory."
        exit 1
    fi
    
    # Run all checks and deployment steps
    check_docker
    check_convex_dependency
    check_env_file
    validate_convex_credentials
    verify_convex_setup
    cleanup_docker
    deploy_services
    verify_deployment
    show_next_steps
    
    echo ""
    log_success "‚úÖ Deployment completed successfully!"
}

# Handle script interruption
trap 'log_error "Deployment interrupted"; exit 1' INT TERM

# Run main function with all arguments
main "$@"
